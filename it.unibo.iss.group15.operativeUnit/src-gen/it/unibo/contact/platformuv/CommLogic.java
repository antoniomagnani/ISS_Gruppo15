/*
*  Generated by AN Unibo
*/
package it.unibo.contact.platformuv;
import it.unibo.is.interfaces.IMessage;
import it.unibo.is.interfaces.IOutputView;
import it.unibo.is.interfaces.platforms.IAcquireOneReply;
import it.unibo.is.interfaces.platforms.IAcquireManyReply;
import it.unibo.is.interfaces.platforms.ILindaLike;
import it.unibo.is.interfaces.platforms.IMessageAndContext;
import java.util.Vector;
import java.util.Iterator;
import it.unibo.is.interfaces.ISysKb;
import java.util.Hashtable;
import it.unibo.is.interfaces.IPolicy;

public class CommLogic{
protected ILindaLike space = LindaLike.getSpace();
protected IOutputView view;
 
	public CommLogic(IOutputView view) {
		this.view = view;
	}
public  IAcquireOneReply outIn( 
		String receiver,String msgId,String sender,String msg,String queryAnswer ) throws Exception {
	IMessage m = new Message(msg);
	outOnly( receiver, msgId ,sender,m  );
	return new AcquireOneReply(sender,receiver, msgId, space,queryAnswer,view);
}


public  void outOnly( String receiver,String msgId,String sender,IMessage msg ) throws Exception {
	ILindaLike support = PlatformExpert.findOutSupport(receiver, msgId ,sender,view);
	if( ! (support instanceof LindaLike) ){
	//Store a outgoing message in the space, to allow observation (with destruction)
	if( ((LindaLike)space).countObservers() > 0 ){
		IMessage m = new Message("outgoing(" + msg +")");
		space.out(""+m);
	}
	}
 	//Send on the network if the outgoing message is still in
	//if( space.rd( 0, ""+m) != null )
 		support.out(""+msg);
}


//Case for no destination (signals)
public  void outOnly( String sender, String msgId, IMessage msg ) throws Exception {
	ILindaLike support =  PlatformExpert.findOutSupport("", msgId ,sender,view);
	if( ! (support instanceof LindaLike) ){
	//Store a outgoing message in the space, to allow observation
	IMessage m = new Message("outgoing(" + msg +")");
	space.out(""+m);
	}
		//Send  
	support.out(""+msg);
}

//Operation with answer 
public  IMessageAndContext inOut( String receiver,String msgId, String queryS ) throws Exception {
	ILindaLike support =  PlatformExpert.findInSupport(receiver, msgId ,  true, view);
		IMessage inMsg =  space.in( queryS );
	return new MessageAndContext(support,inMsg,receiver); //support is needed to send the answer
}

public  IMessage  inOutAck( String receiver,String msgId, String queryS ) throws Exception {
	ILindaLike support =  PlatformExpert.findInSupport(receiver, msgId ,  true,view);
		IMessage inMsg =  space.in( queryS );	
	String channelId = MsgUtil.channel3( inMsg.msgEmitter(), receiver, msgId);
	//String outMsg = MsgUtil.bm(channelId, receiver, msgId , "endOfAnswerSysMsg", inMsg.msgNum());
	//support.out( outMsg ); //support is needed to send the answer
	String outMsg = MsgUtil.bm(channelId, receiver, msgId , IMessageAndContext.endMessage, inMsg.msgNum());
	support.out( outMsg ); //support is needed to send the answer
	return inMsg; 
}

//Operation without answer (serve sense)
public  IMessage inOnly( String receiver, String msgId,  String queryS ) throws Exception {
	//ILindaLike support =  
			PlatformExpert.findInSupport(receiver, msgId , false, view); //to start the support, if any
 	IMessage inMsg     =  space.in( queryS );
	return inMsg;
}

public  IMessage inOnly( String receiver, String msgId,  IMessage queryS ) throws Exception {
	//ILindaLike support =  
			PlatformExpert.findInSupport(receiver, msgId , false, view); //to start the support, if any
 	IMessage inMsg     =  space.in( ""+queryS );
	return inMsg;
}

public  IMessage rd( String receiver, String msgId, Hashtable<String,Integer> lastMsgRdMemo, String queryS ) throws Exception {
	//A look in local space, in any case
	IMessage inMsg = space.rd( lastMsgRdMemo.get(msgId+receiver), queryS ) ;
		//System.out.println("		**** CommLogic rd msgNum=" + inMsg.msgNum() + "/getMsgNum=" + inMsg.getMsgSeqNum());
	if( inMsg != null ) lastMsgRdMemo.put(msgId+receiver, inMsg.getMsgSeqNum() );
	return inMsg;
}
//IMessage rd version
public  IMessage rd( String receiver, String msgId, Hashtable<String,Integer> lastMsgRdMemo, IMessage queryS ) throws Exception {
	return rd(receiver,msgId,lastMsgRdMemo,""+queryS);
}
public  IMessage rdMostRecent( String receiver, String msgId, Hashtable<String,Integer> lastMsgRdMemo, String queryS ) throws Exception {
	//A look in local space, in any case
		IMessage inMsg = space.rdMostRecent( lastMsgRdMemo.get(msgId+receiver), queryS ) ;
	//System.out.println("		**** CommLogic rdwMostRecent msgNum=" + inMsg.msgNum() + "/getMsgNum=" + inMsg.getMsgSeqNum());
	if( inMsg != null ) lastMsgRdMemo.put(msgId+receiver, inMsg.getMsgSeqNum() );
	return inMsg;
}
//IMessage rdMostRecent version
public  IMessage rdMostRecent( String receiver, String msgId, Hashtable<String,Integer> lastMsgRdMemo, IMessage queryS ) throws Exception {
	return rdMostRecent(receiver,msgId,lastMsgRdMemo,""+queryS);
}
public  IMessage rdw( String receiver, String msgId, Hashtable<String,Integer> lastMsgRdMemo,String queryS ) throws Exception {
	//A look in local space, in any case
		IMessage inMsg = space.rdw( lastMsgRdMemo.get(msgId+receiver), queryS ) ;
	//System.out.println("		**** CommLogic rdwMostRecent msgNum=" + inMsg.msgNum() + "/getMsgNum=" + inMsg.getMsgSeqNum());
	lastMsgRdMemo.put(msgId+receiver, inMsg.getMsgSeqNum() );
	return inMsg;
}

//IMessage rdw version
public  IMessage rdw( String receiver, String msgId, Hashtable<String,Integer> lastMsgRdMemo,IMessage queryS ) throws Exception {
 	return rdw(receiver,msgId,lastMsgRdMemo,""+queryS);
}

public  IMessage rdwMostRecent( String receiver, String msgId, Hashtable<String,Integer> lastMsgRdMemo,String queryS ) throws Exception {
	//A look in local space, in any case
		IMessage inMsg = space.rdwMostRecent( lastMsgRdMemo.get(msgId+receiver), queryS ) ;
	//System.out.println("		**** CommLogic rdwMostRecent msgNum=" + inMsg.msgNum() + "/getMsgNum=" + inMsg.getMsgSeqNum());
	lastMsgRdMemo.put(msgId+receiver, inMsg.getMsgSeqNum() );
	return inMsg;
}
//IMessage rdwMostRecent version
public  IMessage rdwMostRecent( String receiver, String msgId, Hashtable<String,Integer> lastMsgRdMemo,IMessage queryS ) throws Exception {
 	return rdwMostRecent(receiver,msgId,lastMsgRdMemo,""+queryS);
}
/*
*  MANY OUT
*/
public IAcquireManyReply outMany(
		String senderName, String msgId, Vector<String> recNames, 
		Vector<String> msgOut, Vector<String> queries) throws Exception{
	Vector<ILindaLike> supports = prepareSupports(senderName,msgId,recNames);
	return doOutMany( senderName,supports.iterator(),  msgOut.iterator(), queries.iterator() );
}

protected Vector<ILindaLike> prepareSupports( 
			String senderName, String msgId, Vector<String> recNames ) throws Exception{
	Vector<ILindaLike> supports = new Vector<ILindaLike>();
	Iterator<String> itr 	= recNames.iterator();
	while( itr.hasNext() ){
		supports.add( findOutSupport(senderName,msgId,itr.next()) );
 	}	
	return supports;
}

protected ILindaLike findOutSupport(
	String senderName, String msgId, String receiverName ) throws Exception{
	return PlatformExpert.findOutSupport(receiverName, msgId ,senderName ,view);
}

protected IAcquireManyReply doOutMany( String subjName,Iterator<ILindaLike> itsup, 
        Iterator<String> itmsgOut, Iterator<String> itquery) throws Exception{
Vector<IMessage> querySet 	= new Vector<IMessage>();
	while( itsup.hasNext() ){
		ILindaLike supp = itsup.next();
		String msg 		= itmsgOut.next();
		String query 	= itquery.next();
		querySet.add( new Message(query) );
		new ExecOut(supp,msg ).start();	
	}
	AcquireManyReply replyHandle = new AcquireManyReply(subjName,querySet,view);
	return replyHandle;
}
private class ExecOut extends Thread{
	private ILindaLike supp ;
	private String msg;
	public ExecOut(ILindaLike supp,String msg){
		this.supp = supp;
		this.msg = msg;
	}
	public void run(){
		try {
			supp.out( msg );
		} catch (Exception e) {
			//Generate an exception message TODO
//			LindaLike.getSpace().out( " " );
			System.out.println( "		**** ExecOut ERROR " + e);
		}
	}
}

/*
*  MANY IN
*/
public Vector<IMessage> prepareInput(boolean mostRecent,String subjName, ISysKb kb, String[] msgList,  
		 IPolicy policy ) throws Exception {
	Vector<IMessage> inpList = new Vector<IMessage>();
	int n = msgList.length;
 	for( int i=0; i<n;i++ ){
		String msgId = msgList[i];
		//System.out.println("		prepareInput " + msgId);
		IMessage m;
		if( kb.isSignal(msgId))
			//m= new Message( MsgUtil.bm( msgId, "SOURCE", msgId, "ANYx1y2", "N")) ;
			m= new Message( MsgUtil.bm( "signal", "SOURCE", msgId, "ANYx1y2", "N")) ;
		else{
			PlatformExpert.findInSupport(subjName,msgId,RunTimeKb.getInputConnMsg(msgId),view );
			 m = new Message(
				 MsgUtil.bm(MsgUtil.channelInWithPolicy(policy,subjName, msgId), 
				 	"SOURCE", msgId, "ANYx1y2", "N")) ;
				 	
  		}
  		inpList.add( m );
	}
//Added to handle signal in a distributed space
 	prepareSignalHandling( mostRecent, kb, subjName, inpList );
//End Added  
	return inpList;
}

public Vector<IMessage> prepareInput(boolean mostRecent, String subjName, ISysKb kb, Object[] msgList,  
		 IPolicy policy ) throws Exception {
	Vector<IMessage> inpList = new Vector<IMessage>();
	int n = msgList.length;
 	for( int i=0; i<n;i++ ){
		String msgId = (String)msgList[i];
		//System.out.println("		prepareInput " + msgId);
		IMessage m;
		if( kb.isSignal(msgId))
			m= new Message( MsgUtil.bm( "signal", "SOURCE", msgId, "ANYx1y2", "N")) ;
			//m= new Message( MsgUtil.bm( msgId, "SOURCE", msgId, "ANYx1y2", "N")) ;
		else{
			PlatformExpert.findInSupport(subjName,msgId,RunTimeKb.getInputConnMsg(msgId),view );
			 m = new Message(
				 MsgUtil.bm(MsgUtil.channelInWithPolicy(policy,subjName, msgId), 
				 	"SOURCE", msgId, "ANYx1y2", "N")) ;
				 	
  		}
  		inpList.add( m );
	}
//Added to handle signal in a distributed space
 	prepareSignalHandling( mostRecent, kb, subjName, inpList );
//End Added  
	return inpList;
}

/*
* Start SenseRemote for each signal
* and modifies the content of the givan input lists
* All the signals are put at the end of the queries
* TOCHECK
*/
protected void prepareSignalHandling( boolean mostRecent,ISysKb kb, String subjName,Vector<IMessage> queries){
 for( int i=0; i<queries.size(); i++ ){
	   IMessage first = queries.elementAt(i);
	   String queryId = first.msgId();
	   //System.out.println(" *** prepareSignalHandling queryId "  +  queryId   );
	   //TO REMOVE
	   //if( kb.isSignal( queryId ) ){
		//SenseRemote.doJob(first.toString(),queryId,subjName, mostRecent, space,view);	//acquire all
  	   //}
 }//for	 
}
/* TO BE REMOVED since we must avoid duplicates
protected synchronized void acquireDSpaceAnswer(final SenseRemote curJob ) throws Exception{
 	IMessage m = curJob.getAnswer();
	//System.out.println(" 				*** acquireDSpaceAnswer m "  +  m   );
	space.out( m.toString() );
	curJob.repeat();
	//Prepare to acquire the answer from that specific thread and repeat
	   new Thread(){
		   public void run(){
			   try {
				acquireDSpaceAnswer(curJob);
			} catch (Exception e) {
					e.printStackTrace();
			}
		   }
	   }.start();
}
*/

//Select a message
public IMessage selectOneMessage( boolean mostRecent, String subjName,ISysKb kb, Hashtable<String,Integer> lastMsgRdMemo,
        Vector<IMessage> queries ) throws Exception {
IMessage mr;
   	if( mostRecent )
   		mr = space.selectMostRecent(subjName,lastMsgRdMemo, queries);
	else        	
 		mr = space.select(subjName,lastMsgRdMemo, queries);
   //if( kb.isSignal( mr.msgId() )){
   int lastMsgNum = mr.getMsgSeqNum();
   lastMsgRdMemo.put(mr.msgId()+subjName, lastMsgNum); //SET THE LOCAL TIME
   //System.out.println("			*** CommLogic " + subjName + " selectOneMessage "  +  mr + " lastMsgNum=" + lastMsgNum);
 //}
 return mr;
}
 
/*
* Called by the application main to terminates all the SenseRemote threads
*/
public static void terminate() throws Exception{
}

}
